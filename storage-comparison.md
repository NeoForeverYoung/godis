# Redis、godis和TinyKV存储实现对比

## 1. 架构概述

| 系统 | 类型 | 主要语言 | 架构特点 |
| --- | --- | --- | --- |
| Redis | 内存数据库 | C | 单节点、单线程模型 |
| godis | Redis实现 | Go | 单节点、并发模型 |
| TinyKV | 分布式存储 | Go | 分布式、基于Raft共识算法 |

## 2. 核心数据结构

### Redis
- 使用哈希表作为核心数据结构
- 采用链地址法解决哈希冲突
- 全局哈希表包含两个哈希表实例(dict.ht[2])，支持rehash

### godis
- 使用分片哈希表设计(`ConcurrentDict`)
- 哈希表由多个分片(`shard`)组成，每个分片包含一个Go原生`map`和互斥锁
- 使用fnv32哈希算法将键映射到不同分片

### TinyKV
- 基于LSM树(Log-Structured Merge Tree)的BadgerDB作为底层存储引擎
- 使用B-Tree存储和管理区域信息
- 使用红黑树进行内存存储
- 实现多版本并发控制(MVCC)

## 3. 扩容/数据管理策略

### Redis
- 渐进式rehash机制
  - 同时使用两个哈希表(ht[0]和ht[1])
  - 当需要扩容时，为ht[1]分配更大空间
  - 处理请求时逐步将数据从ht[0]迁移到ht[1]
  - 迁移完成后，释放ht[0]，将ht[1]设为ht[0]
- 避免一次性rehash导致的服务阻塞

### godis
- 创建时确定分片数量(shardCount)，不支持动态扩容
- 通过`computeCapacity`函数计算适当的分片容量
- 内部使用Go原生map，依赖Go运行时对map的自动扩容
- 没有实现类似Redis的渐进式rehash机制

### TinyKV
- 基于LSM树的后台压缩(compaction)过程管理数据
- 将写操作先记录在内存中，定期合并到有序文件中
- 通过多层合并策略平衡读写性能
- Region分裂与合并处理数据分布

## 4. 并发处理方式

### Redis
- 单线程模型，所有操作按顺序执行
- 通过IO多路复用处理并发连接
- 避免多线程带来的锁和同步开销

### godis
- 多线程并发模型
- 每个分片(`shard`)使用独立的读写锁(`sync.RWMutex`)
- 细粒度锁策略减少锁竞争
- 通过哈希算法分散键的分布，提高并发性能

### TinyKV
- 分布式系统，使用Raft共识算法确保数据一致性
- 使用MVCC(多版本并发控制)实现事务
- 通过Region划分和调度实现横向扩展

## 5. 优缺点分析

### Redis
**优点:**
- 简单高效的内存数据结构
- 渐进式rehash避免长时间阻塞
- 单线程模型避免锁开销，简化实现

**缺点:**
- 内存容量限制
- 单节点架构容量受限
- 主从复制可能有延迟

### godis
**优点:**
- 利用Go语言并发特性提高性能
- 分片设计减少锁竞争
- 实现简单，容易理解

**缺点:**
- 无法动态调整分片数量
- 缺乏渐进式rehash，可能在Go map自动扩容时有性能抖动
- 并发操作增加了实现复杂性

### TinyKV
**优点:**
- 分布式架构，支持水平扩展
- LSM树提供高写入性能
- Raft协议保证数据一致性

**缺点:**
- 系统复杂度高
- LSM树读放大问题
- 维护和运维成本高

## 6. 总结

这三个系统采用了不同的数据结构和策略来解决各自场景下的问题：

- **Redis** 专注于高性能内存数据库，通过渐进式rehash优化哈希表扩容
- **godis** 采用Go语言特性实现并发友好的分片哈希表，简化设计
- **TinyKV** 作为分布式存储系统，使用LSM树和Raft共识算法解决大规模数据存储问题

选择哪种方案取决于具体应用场景的需求，包括数据规模、一致性要求、性能期望和部署环境等因素。 